# -*- coding: utf-8 -*-
"""Exam_Kimia Haghjooei_9952521004.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EHgRdVfemv42-ZGd-wnPQUXiVZ81m2a4
"""

import cv2 
import numpy as np

def processImage(image): 
  image = cv2.imread(image) 
  image = cv2.cvtColor(src=image, code=cv2.COLOR_BGR2GRAY) 
  return image

def convolve2D(image,kernel,padding=0,strides=1):
    # Cross Correlation

    kernel = np.flipud(np.fliplr(kernel))

    # Gather Shapes of Kernel + Image + Padding
    xKernShape = kernel.shape[0]
    yKernShape = kernel.shape[1]
    xImgShape = image.shape[0]
    yImgShape = image.shape[1]

    # Shape of Output Convolution
    xOutput = int(((xImgShape - xKernShape + 2 * padding) / strides) + 1)
    yOutput = int(((yImgShape - yKernShape + 2 * padding) / strides) + 1)
    output = np.zeros((xOutput, yOutput))

    # Apply Equal Padding to All Sides
    if padding != 0:
        imagePadded = np.zeros((image.shape[0] + padding*2, image.shape[1] + padding*2))
        imagePadded[int(padding):int(-1 * padding), int(padding):int(-1 * padding)] = image
        print(imagePadded)
    else:
        imagePadded = image

    # Iterate through image
    for y in range(image.shape[1]):
        # Exit Convolution
        if y > image.shape[1] - yKernShape:
            break
        # Only Convolve if y has gone down by the specified Strides
        if y % strides == 0:
            for x in range(image.shape[0]):
                # Go to next row once kernel is out of bounds
                if x > image.shape[0] - xKernShape:
                    break
                try:
                    # Only Convolve if x has moved by the specified Strides
                    if x % strides == 0:
                        output[x, y] = (kernel * imagePadded[x: x + xKernShape, y: y + yKernShape]).sum()
                except:
                    break

    return output

from google.colab import files
uploa22ded = files.upload()

image = processImage('Image.jpeg')
#image=np.random.rand(5,5)
numz1=int(input("Enter the number of channels of the first conv"))
numz2=int(input("Enter the number of channels of the second conv"))
numz3=int(input("Enter the number of channels of the third conv"))
mask=int(input("Enter the dimention of mask"))
def mult(x,y):
  o=[]
  j=0
  for i in range(0,len(x)):
    for j in range(0,len(y)):
      o.append(x[i]*y[j])
  return o

#forward:
#first conv layer
np.random.seed(2)
a1=np.random.rand(numz1)
b1=np.random.rand(1) 
c1=np.random.rand(mask)
d1=np.random.rand(mask)
print(a1)
print(b1)
print(c1)
print(d1)
o=mult(c1,d1)
c1d1=np.reshape(o,(-1,len(d1)))
z1=[]
for i in range(0,numz1):
  c1d1_=a1[i]*b1*c1d1
  kernel=np.array(c1d1_)
  output = convolve2D(image, kernel)
  #cv2.imwrite('2DConvolved.jpg', output)
  z1.append(output)

#second conv layer
 #W=a.b.c.d
np.random.seed(3)
a2=np.random.rand(numz2)
b2=np.random.rand(numz1)
c2=np.random.rand(mask)
d2=np.random.rand(mask)
print(a2)
print(b2)
print(c2)
print(d2)
o=mult(c2,d2)
c2d2=np.reshape(o,(-1,len(d2)))
z2=[]
for i in range(0,numz2):
  for j in range(0,numz1):
    c2d2_=a2[i]*b2[j]*c2d2
    kernel=np.array(c2d2_)
    output = convolve2D(z1[j], kernel)
    #cv2.imwrite('2DConvolved.jpg', output)
    z2.append(output)

#third conv layer
np.random.seed(4)
a3=np.random.rand(numz3)
b3=np.random.rand(numz2)
c3=np.random.rand(mask)
d3=np.random.rand(mask)
print(a3)
print(b3)
print(c3)
print(d3)
o=mult(c3,d3)
c3d3=np.reshape(o,(-1,len(d3)))
z3=[]
for i in range(0,numz3):
  for j in range(0,numz2):
    c3d3_=a3[i]*b3[j]*c3d3
    kernel=np.array(c3d3_)
    output = convolve2D(z2[j], kernel)
    #cv2.imwrite('2DConvolved.jpg', output)
    z3.append(output)

from google.colab.patches import cv2_imshow
for z in z3:
  print(z)
  cv2_imshow(z)
  #cv2.imshow(window_name, image)
  #cv2.imwrite('2DConvolved.jpg', z)

#Folding:
z4=np.reshape(z3,-1)
z4_=np.reshape(z4,(-1,len(z4)))
y=np.array([1])
#print(z4.shape)
#print(z4_.shape)
#print(z4)
#Fully Connected:
from keras.models import Sequential
from keras.layers import Dense
model = Sequential()
model.add(Dense(10, activation='sigmoid'))
model.add(Dense(10, activation='sigmoid'))
model.add(Dense(1, activation='sigmoid'))
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])
model.fit(z4_, y)

#backward:
def derivative_sigmoid(x):
    return x * (1 - x)
def conv_backward(dZ, cache):
    (A_prev, W, b, hparameters) = cache
    (m, n_H_prev, n_W_prev, n_C_prev) = A_prev.shape
    (f, f, n_C_prev, n_C) = W.shape
    stride = hparameters["stride"]
    pad = hparameters["pad"]
    (m, n_H, n_W, n_C) = dZ.shape
    dA_prev = np.zeros((m, n_H_prev, n_W_prev, n_C_prev))                           
    db = np.zeros((1, 1, 1, n_C))
    A_prev_pad = zero_pad(A_prev, pad)
    dA_prev_pad = zero_pad(dA_prev, pad)
    for i in range(m):                      
        a_prev_pad = A_prev_pad[i]
        da_prev_pad = dA_prev_pad[i]
        for h in range(n_H):                   
            for w in range(n_W):               
                for c_ in range(n_C):           
                    vert_start = h
                    vert_end = vert_start + f
                    horiz_start = w
                    horiz_end = horiz_start + f
                    a_slice = a_prev_pad[vert_start:vert_end, horiz_start:horiz_end, :]
                    da_prev_pad[vert_start:vert_end, horiz_start:horiz_end, :] += a*b*c*d[c_] * dZ[i, h, w, c_]
                    da[c_] += b*c*d*a_slice*dZ[i, h, w, c_]
                    db[c_] += a*c*d*a_slice*dZ[i, h, w, c_]
                    dc[c_] += a*b*d*a_slice*dZ[i, h, w, c_]
                    dd[c_] += a*b*c*a_slice*dZ[i, h, w, c_]
                    dbi[:,:,:,c_] += dZ[i, h, w, c_]     
        dA_prev[i, :, :, :] = da_prev_pad[pad:-pad, pad:-pad, :]
    assert(dA_prev.shape == (m, n_H_prev, n_W_prev, n_C_prev))   
    return dA_prev,da,db,dc,dd,dbi
def FCbackward(X,y,y_hat):
  y_hat_err=y-(y_hat)
  y_hat_d=np.dot(y_hat_err,derivative_sigmoid(z4_,y_hat)) 
  W3_d=np.dot(h2.reshape(4,1),y_hat_d.reshape(1,3))
  h2_d=np.dot(W3,y_hat_d)
  a2_d=np.dot(h2_d,derivative_sigmoid(a2))
  W2_d=np.dot(a2_d,h1.T)
  h1_d=np.dot(W2.T,a2_d)
  a1_d=np.dot(h1_d,derivative_sigmoid(a1))
  W1_d=np.dot(a1_d,X.T)
  W1+=np.dot(W1_d.T,X)
  W2+=np.dot(W2_d.T,h1)
  W3+=np.dot(W3_d.T,h2)
